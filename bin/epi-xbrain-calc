#!/usr/bin/env python
"""
Produces a subject x ROI .csv containing the correlations of that subject's
brain activity to the submitted template, which is a ROI x timepoint .csv
such as those generated by epi-xbrain-template.

The number of rows in the output .csv will match the number of input NIFTIs.

Usage:
    epi-xbrain-calc [options] <output> <template> <seeds> <nifti>...

Arguments:
    <output>        Output .csv filename.
    <template>      Input template .csv filename.
    <seeds>         Mask with one or more ROI.
    <nifti>         Input niftis for subjects.

Options:
    --mask=<mask>   A binary brain mask.

DETAILS

    This computes the correlation of the mean time series within each ROI in
    the supplied mask with the template, for each subject.

    This program treats each unique input value in the seeds NIFTI as a unique
    ROI.

    epi-xbrain-calc -h or --help prints this message.
"""

import sys
import numpy as np
import scipy as sp
import nibabel as nib
import epitome as epi
from epitome.docopt import docopt

def get_mean_ts(data, seed):
    """
    takes one mean column of data for each unique value found in seed. returns a
    matrix with the number of rows of each column x the number of unique values
    in seed (excluding zero).
    """
    out_data = np.zeros(np.shape(data)[1])

    # get mean seed stat from each, append to output
    for s in np.unique(seed)[1:]:
        idx = np.where(seed == s)[0]
        seed_data = data[idx, :]
        seed_data = np.mean(seed_data, axis=0)
        out_data = np.vstack((out_data, seed_data))

    # strip off zeros
    out_data = out_data[1:,:]

    return out_data

def main():
    arguments = docopt(__doc__)
    output   = arguments['<output>']
    template = arguments['<template>']
    seed     = arguments['<seeds>']
    data     = arguments['<nifti>']
    mask     = arguments['--mask']

    # check that the inputs are all compatible
    template = np.genfromtxt(template, delimiter=',')
    seed, _, _, _ = epi.utilities.loadnii(seed)
    _, _, _, dims = epi.utilities.loadnii(data[0])

    if mask:
        mask, _, _, _ = epi.utilities.loadnii(mask)
        # attempt to mask out non-brain regions in ROIs
        n_seeds = len(np.unique(seed))
        seed = seed * mask
        if len(np.unique(seed)) != n_seeds:
            sys.exit('ERROR: At least 1 ROI completely outside mask for {}.'.format(output))

    if len(np.unique(seed))-1 != template.shape[0]:
        sys.exit('ERROR: The number of seeds in the input mask does not match the number of timeseries in the supplied template.')

    # init output matrix (TRs / ROIs)
    out_data = np.zeros((len(data), len(np.unique(seed)[1:])))

    for i, subj in enumerate(data):
        d, _, _, _ = epi.utilities.loadnii(subj)
        means = get_mean_ts(d, seed)

        if means.shape != template.shape:
            sys.exit('ERROR: Template does not match input {}.'.format(subj))

        # correlate template + means, save diagonal of off diagonal
        c = np.corrcoef(template, means)
        c = c[c.shape[0]/2:, 0:c.shape[0]/2]
        out_data[i, :] = c.diagonal()

    # write outputs
    np.savetxt(output, out_data, delimiter=",")

if __name__ == '__main__':
    main()

