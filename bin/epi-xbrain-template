#!/usr/bin/env python
"""
Produces a .csv of the mean timeseries from each ROI defined in the input mask
across all of the input niftis. All time series are scaled to percent signal
change before calculation.

Usage:
    epi-xbrain-template [options] <output> <seeds> <nifti>...

Arguments:
    <output>        Output .csv filename.
    <seeds>         Mask with one or more ROI.
    <nifti>         Input niftis for subjects.

Options:
    --mask=<mask>   A binary brain mask.
    --var=<var>     Compute the variance of the timeseries between subjects.

DETAILS

    This computes the mean time series within each ROI in the supplied mask.
    This program treats each unique input value in the seeds NIFTI as a unique
    ROI. It takes the mean time series within that ROI, and then takes the mean
    time series between those ROIs to create a group template.

    epi-xbrain-template -h or --help prints this message.
"""

import sys
import numpy as np
import scipy as sp
import nibabel as nib
import epitome as epi
from epitome.docopt import docopt

def get_mean_ts(data, seed):
    """
    takes one mean column of data for each unique value found in seed. returns a
    matrix with the number of rows of each column x the number of unique values
    in seed (excluding zero).

    Each time series is finally converted to percent signal change by subtracting
    the mean and dividing by the mean.
    """
    out_data = np.zeros(np.shape(data)[1])

    # get mean seed stat from each, append to output
    for s in np.unique(seed)[1:]:
        idx = np.where(seed == s)[0]
        seed_data = data[idx, :]
        seed_data = np.mean(seed_data, axis=0)
        out_data = np.vstack((out_data, seed_data))

    # strip off zeros
    out_data = out_data[1:,:]

    # convert to percent signal change
    means = np.tile(np.mean(out_data, axis=1), [out_data.shape[1], 1]).transpose()
    out_data = (out_data-means)/means * 100

    return out_data

def main():
    arguments = docopt(__doc__)
    output = arguments['<output>']
    seed   = arguments['<seeds>']
    data   = arguments['<nifti>']
    mask   = arguments['--mask']
    var    = arguments['--var']

    if len(data) < 2:
        sys.exit('ERROR: Need at least two inputs to average')

    seed, _, _, _ = epi.utilities.loadnii(seed)
    _, _, _, dims = epi.utilities.loadnii(data[0])

    if mask:
        mask, _, _, _ = epi.utilities.loadnii(mask)
        # attempt to mask out non-brain regions in ROIs
        n_seeds = len(np.unique(seed))
        seed = seed * mask
        if len(np.unique(seed)) != n_seeds:
            sys.exit('ERROR: At least 1 ROI completely outside mask for {}.'.format(output))

    # init output matrix (TRs / ROIs)
    out_data = np.zeros((len(np.unique(seed)[1:]), dims[3]))
    if var:
        outvar = np.zeros((len(np.unique(seed)[1:]), dims[3], len(data)))

    for i, subj in enumerate(data):
        subj, _, _, _ = epi.utilities.loadnii(subj)
        means = get_mean_ts(subj, seed)
        if var:
            outvar[:,:,i] = means
        out_data = out_data + means

    # write outputs
    out_data = out_data / len(subj)
    np.savetxt(output, out_data, delimiter=",")

    if var:
        outvar = np.var(outvar, axis=2)
        np.savetxt(var, out_data, delimiter=",")

if __name__ == '__main__':
    main()

